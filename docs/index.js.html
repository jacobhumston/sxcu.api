<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: index.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="",baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="dark" data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="CP0tdVsklKMPUSKxKLF_K"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Utility_queue.html">queue</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="ZU_t2b0sSlX75_L9zNS9U"><div>Namespaces</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Collections.html">Collections</a></div><div class="sidebar-section-children"><a href="Files.html">Files</a></div><div class="sidebar-section-children"><a href="Links.html">Links</a></div><div class="sidebar-section-children"><a href="Subdomains.html">Subdomains</a></div><div class="sidebar-section-children"><a href="Text.html">Text</a></div><div class="sidebar-section-children"><a href="Utility.html">Utility</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="AhGoesvHZVs2-NAnWF6WB"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-obeying-rate-limits.html">Obeying Rate Limits</a></div><div class="sidebar-section-children"><a href="tutorial-uploading-a-file.html">Uploading a File</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="xDMjSmo5Yc5y1efemKz9B"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#CollectionMetaResponse">CollectionMetaResponse</a></div><div class="sidebar-section-children"><a href="global.html#CollectionMetaResponseFile">CollectionMetaResponseFile</a></div><div class="sidebar-section-children"><a href="global.html#ConvertedSxcuFile">ConvertedSxcuFile</a></div><div class="sidebar-section-children"><a href="global.html#CreatedCollectionResponse">CreatedCollectionResponse</a></div><div class="sidebar-section-children"><a href="global.html#CreatedLinkResponse">CreatedLinkResponse</a></div><div class="sidebar-section-children"><a href="global.html#CreatedPasteResponse">CreatedPasteResponse</a></div><div class="sidebar-section-children"><a href="global.html#ErrorResponse">ErrorResponse</a></div><div class="sidebar-section-children"><a href="global.html#FileMetaResponse">FileMetaResponse</a></div><div class="sidebar-section-children"><a href="global.html#FileMetaResponseOpenGraphProperties">FileMetaResponseOpenGraphProperties</a></div><div class="sidebar-section-children"><a href="global.html#FilePath">FilePath</a></div><div class="sidebar-section-children"><a href="global.html#RateLimit">RateLimit</a></div><div class="sidebar-section-children"><a href="global.html#RateLimitData">RateLimitData</a></div><div class="sidebar-section-children"><a href="global.html#Snowflake">Snowflake</a></div><div class="sidebar-section-children"><a href="global.html#SubdomainListData">SubdomainListData</a></div><div class="sidebar-section-children"><a href="global.html#SubdomainMetaResponse">SubdomainMetaResponse</a></div><div class="sidebar-section-children"><a href="global.html#URL">URL</a></div><div class="sidebar-section-children"><a href="global.html#UploadFileOptions">UploadFileOptions</a></div><div class="sidebar-section-children"><a href="global.html#UploadFileOptionsOpenGraphProperties">UploadFileOptionsOpenGraphProperties</a></div><div class="sidebar-section-children"><a href="global.html#UploadedFileResponse">UploadedFileResponse</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">index.js</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * @file sxcu.api library.
 * @author Jacob Humston
 */

// Modules
const fs = require('fs');

// Configuration
const packageVersion = require('../package.json').version;
const packageUrl = 'https://github.com/Lovely-Experiences/sxcu.api';
const baseUrl = 'https://sxcu.net/api';
const textBaseUrl = 'https://cancer-co.de/';
let userAgent = `sxcu.api/v${packageVersion} (+${packageUrl}) - Node.js ${process.version}`;

// Data Objects
const rateLimitData = {};

// Private Methods &amp; Types
/**
 * Save data that is provided from rate limit headers.
 * @function saveRateLimitData
 * @param {Headers} headers
 * @param {string} functionName
 * @returns {null}
 * @private
 */
function saveRateLimitData(headers, functionName) {
    const data = {};
    let isGlobal = false;
    data.limit = headers.get('X-RateLimit-Limit');
    data.remaining = headers.get('X-RateLimit-Remaining');
    data.reset = headers.get('X-RateLimit-Reset');
    data.resetAfter = headers.get('X-RateLimit-Reset-After');
    data.bucket = headers.get('X-RateLimit-Bucket');
    if (headers.get('X-RateLimit-Global') !== null) {
        isGlobal = true;
    }
    if (data.limit === null || data.remaining === null || data.reset === null || data.bucket === null) return null;
    data.limit = Number(data.limit);
    data.remaining = Number(data.remaining);
    data.reset = Number(data.reset);
    data.resetAfter = Number(data.resetAfter);
    data.resetDate = new Date((data.reset + 1) * 1000);
    if (isGlobal === false) {
        for (const bucket in rateLimitData) {
            if (rateLimitData[bucket].functions.findIndex((name) => name === functionName) !== -1) {
                if (bucket !== data.bucket) {
                    delete rateLimitData[bucket];
                }
            }
        }
        if (rateLimitData[data.bucket]) {
            rateLimitData[data.bucket].lastRateLimit = data;
            if (rateLimitData[data.bucket].functions.findIndex((name) => name === functionName) === -1) {
                rateLimitData[data.bucket].functions.push(functionName);
            }
        } else {
            rateLimitData[data.bucket] = {
                functions: [functionName],
                bucket: data.bucket,
                lastRateLimit: data,
                global: false,
            };
        }
    } else {
        rateLimitData['global'] = {
            functions: [],
            bucket: data.bucket,
            lastRateLimit: data,
            global: true,
        };
    }
    return null;
}

// Public Methods
/**
 * Represents a Snowflake.
 * @typedef {string} Snowflake
 */

/**
 * Represents a URL.
 * @typedef {string} URL
 */

/**
 * Represents an error response.
 * @typedef {Object} ErrorResponse
 * @property {string} error Error message.
 * @property {number} code Internal error code.
 */

/**
 * Represents a path to a file.
 * @typedef {string} FilePath
 */

/**
 * Methods that interact with the "Files" endpoint.
 * @namespace Files
 * @example
 * const { files: sxcuFiles } = require("sxcu.api"); // sxcuFiles.&lt;method>
 * const { files } = require("sxcu.api"); // files.&lt;method>
 * const sxcu = require("sxcu.api"); // sxcu.files.&lt;method>
 */
exports.files = {
    /**
     * Represents OpenGraph properties of a file meta response.
     * @typedef {Object} FileMetaResponseOpenGraphProperties
     * @property {string} [color] OpenGraph HEX color code.
     * @property {string} [title] OpenGraph title.
     * @property {string} [description] OpenGraph description.
     * @property {boolean} [discordHideURL] Whether to hide this file's url in Discord or not when sent.
     */

    /**
     * Represents the response returned by 'getFileMeta'.
     * @typedef {Object} FileMetaResponse
     * @property {Snowflake} id ID of the file created.
     * @property {URL} url Public URL of the file.
     * @property {number} views File view count.
     * @property {boolean} viewable Wether the file can be viewed or not.
     * @property {Snowflake?} collection ID of the collection that this file is associated with.
     * @property {number} size File size in bytes.
     * @property {number} creationTime Unix timestamp of when the file was created.
     * @property {Date} creationTimeDate 'creationTime' converted to date object.
     * @property {FileMetaResponseOpenGraphProperties|undefined} openGraphProperties OpenGraph properties for this file.
     */

    /**
     * Get the meta info of a file.
     * @function getFileMeta
     * @param {Snowflake} fileId ID of the file to get the meta info of.
     * @returns {Promise&lt;FileMetaResponse>}
     * @throws {ErrorResponse|any}
     * @memberof Files
     * @instance
     */
    getFileMeta: async function (fileId) {
        return new Promise(function (resolve, reject) {
            fetch(`${baseUrl}/files/${fileId}`, {
                method: 'GET',
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'getFileMeta');
                    if (response.status === 200) {
                        const parsedData = await response.json();
                        const resolvedData = {};
                        resolvedData.id = parsedData.id;
                        resolvedData.url = parsedData.url;
                        resolvedData.views = parsedData.views;
                        resolvedData.viewable = parsedData.viewable;
                        resolvedData.collection = parsedData.collection;
                        resolvedData.size = parsedData.size;
                        resolvedData.creationTime = parsedData.creation_time;
                        resolvedData.creationTimeDate = new Date(resolvedData.creationTime * 1000);
                        if (parsedData.og_properties !== undefined) {
                            resolvedData.openGraphProperties = {};
                            resolvedData.openGraphProperties.color = parsedData.og_properties.color;
                            resolvedData.openGraphProperties.title = parsedData.og_properties.title;
                            resolvedData.openGraphProperties.description = parsedData.og_properties.description;
                            resolvedData.openGraphProperties.discordHideURL = parsedData.og_properties.discord_hide_url;
                        }
                        resolve(resolvedData);
                    } else if (response.status === 400 || response.status === 429) {
                        const parsedData = await response.json();
                        reject({
                            error: parsedData.error,
                            code: parsedData.code,
                        });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },

    /**
     * Represents OpenGraph properties for UploadFileOptions.
     * @typedef {Object} UploadFileOptionsOpenGraphProperties
     * @property {string|false} [title] Configures the value for the 'title' OpenGraph meta tag, if set to false, the tag will be omitted entirely.
     * @property {string|false} [description] Configures the value for the 'description' OpenGraph meta tag, if set to false, the tag will be omitted entirely.
     * @property {string|false} [color] Configures the value for the 'theme-color' OpenGraph meta tag, must be a valid HEX color code, if set to false, the tag will be omitted entirely.
     * @property {string|false} [siteName] Configures the value for the 'site-name' OpenGraph meta tag, if set to false, the tag will be omitted entirely.
     * @property {boolean} [discordHideUrl] If false, discord will not hide the url of the file when sent as a direct link.
     */

    /**
     * Options for uploading a file.
     * @typedef {Object} UploadFileOptions
     * @property {string} [token] Subdomain's upload token.
     * @property {Snowflake} [collection] Collection to upload too.
     * @property {string} [collectionToken] Collection's upload token.
     * @property {boolean} [noEmbed] If true, the url will be a link directly to the image instead.
     * @property {boolean} [selfDestruct] If true, the file will be automatically deleted after 24 hours.
     * @property {UploadFileOptionsOpenGraphProperties} [openGraphProperties] OpenGraph properties which allow you to change how the url is embedded on different websites.
     */

    /**
     * Represents the response returned by 'uploadFile'.
     * @typedef {Object} UploadedFileResponse
     * @property {Snowflake} id ID of the uploaded file.
     * @property {URL} url URL of the uploaded file.
     * @property {URL} deletionUrl Deletion URL for the uploaded file.
     * @property {string} deletionToken Deletion token for the uploaded file.
     * @property {URL} thumbnail Thumbnail of the uploaded file.
     */

    /**
     * Upload a file and retrieve and URL for it.
     * @function uploadFile
     * @param {FilePath} file Path of the file to upload.
     * @param {UploadFileOptions} [options] Upload file options.
     * @param {URL} [subdomain] Subdomain to upload the file to. Ex; 'something.shx.gg'
     * @returns {Promise&lt;UploadedFileResponse>}
     * @throws {ErrorResponse|any}
     * @memberof Files
     * @instance
     * @tutorial uploading-a-file
     * @example
     * const sxcu = require("sxcu.api");
     * const options = { openGraphProperties: { siteName: "Test Image". discordHideUrl: false } };
     * const uploadData = await sxcu.files.uploadFile("image.png", options).catch(function (e) { console.log(e); });
     * console.log(uploadData);
     */
    uploadFile: async function (file, options, subdomain) {
        return new Promise(function (resolve, reject) {
            const formData = new FormData();
            try {
                formData.set('file', new Blob([fs.readFileSync(file)]));
            } catch (error) {
                reject({ error: `Couldn't parse file: ${error}`, code: -1 });
            }
            if (options) {
                if (options.token) {
                    formData.set('token', options.token);
                }
                if (options.collection) {
                    formData.set('collection', options.collection);
                }
                if (options.collectionToken) {
                    formData.set('collection_token', options.collectionToken);
                }
                if (options.noEmbed === true) {
                    formData.set('noembed', 'true');
                }
                if (options.selfDestruct === true) {
                    formData.set('self_destruct', 'true');
                }
                if (options.openGraphProperties) {
                    formData.set(
                        'og_properties',
                        JSON.stringify({
                            title: options.openGraphProperties.title,
                            description: options.openGraphProperties.description,
                            color: options.openGraphProperties.color,
                            site_name: options.openGraphProperties.siteName,
                            discord_hide_url: options.openGraphProperties.discordHideUrl,
                        })
                    );
                }
            }
            let url = baseUrl;
            if (subdomain) {
                url = 'https://' + subdomain + '/api';
            }
            fetch(`${url}/files/create`, {
                method: 'POST',
                body: formData,
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'uploadFile');
                    if (response.status === 200) {
                        const data = await response.json();
                        const parsedData = {};
                        parsedData.id = data.id;
                        parsedData.url = data.url;
                        parsedData.deletionUrl = data.del_url;
                        parsedData.deletionToken = data.del_url.split('/').pop();
                        parsedData.thumbnail = data.thumb;
                        resolve(parsedData);
                    } else if (response.status === 400 || response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },

    /**
     * Delete a file using the deletion token.
     * @function deleteFile
     * @param {Snowflake} fileId ID of the file to delete.
     * @param {string} deletionToken Deletion token.
     * @returns {Promise&lt;string>} Message result.
     * @throws {ErrorResponse|any}
     * @memberof Files
     * @instance
     */
    deleteFile: async function (fileId, deletionToken) {
        return new Promise(function (resolve, reject) {
            fetch(`${baseUrl}/files/delete/${fileId}/${deletionToken}`, {
                method: 'GET',
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'deleteFile');
                    if (response.status === 200) {
                        const data = await response.json();
                        return resolve(data.message);
                    } else if (response.status === 400 || response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },
};

/**
 * Methods that interact with the "Subdomains" endpoint.
 * @namespace Subdomains
 * @example
 * const { subdomains: sxcuSubdomains } = require("sxcu.api"); // sxcuSubdomains.&lt;method>
 * const { subdomains } = require("sxcu.api"); // subdomains.&lt;method>
 * const sxcu = require("sxcu.api"); // sxcu.subdomains.&lt;method>
 */
exports.subdomains = {
    /**
     * Represents values returned by 'listSubdomains'.
     * @typedef {Object} SubdomainListData
     * @property {string} domain Name of the subdomain.
     * @property {number} uploadCount Number of files uploaded to this subdomain.
     * @property {boolean} public Whether this subdomain is public or not.
     * @property {number} fileViews Number of files views on this subdomain.
     */

    /**
     * Get a list of all current subdomains with some basic information about each of them.
     * WARNING: This endpoint contains NSFW domain names.
     * @function listSubdomains
     * @returns {Promise&lt;SubdomainListData[]>} An array of subdomain data.
     * @throws {ErrorResponse|any}
     * @memberof Subdomains
     * @instance
     */
    listSubdomains: async function () {
        return new Promise(function (resolve, reject) {
            fetch(`${baseUrl}/subdomains`, {
                method: 'GET',
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'listSubdomains');
                    if (response.status === 200) {
                        const data = await response.json();
                        const dataToReturn = [];
                        for (const subdomain of data) {
                            dataToReturn.push({
                                domain: subdomain.domain,
                                uploadCount: subdomain.upload_count,
                                public: subdomain.public,
                                fileViews: subdomain.file_views,
                            });
                        }
                        resolve(dataToReturn);
                    } else if (response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },

    /**
     * Represents the response returned by 'getSubdomainMeta()'.
     * @typedef {Object} SubdomainMetaResponse
     * @property {Snowflake} id ID of the subdomain.
     * @property {number} files Number of files associated with this subdomain.
     * @property {number} links Number of links associated with this subdomain.
     * @property {number} fileViews Total amount of views that all files got combined that are associated with this subdomain.
     * @property {boolean} public Wether this subdomain is public or not.
     * @property {boolean} root Wether this subdomain is a root domain or not.
     * @property {number} lastActivity Timestamp of last interaction with this subdomain. (File views, file uploads, and file deletions.)
     * @property {Date} lastActivityDate 'lastActivity' converted to date object.
     */

    /**
     * Get the meta info of a subdomain.
     * @function getSubdomainMeta
     * @param {string} subdomain Name of the subdomain to get the meta info of. Ex; 'sxcu.net'
     * @returns {Promise&lt;SubdomainMetaResponse>} Meta information for the subdomain provided.
     * @throws {ErrorResponse|any}
     * @memberof Subdomains
     * @instance
     */
    getSubdomainMeta: async function (subdomain) {
        return new Promise(function (resolve, reject) {
            fetch(`${baseUrl}/subdomains/${subdomain}`, {
                method: 'GET',
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'getSubdomainMeta');
                    if (response.status === 200) {
                        const data = await response.json();
                        const dataToReturn = {};
                        dataToReturn.id = data.id;
                        dataToReturn.files = data.files;
                        dataToReturn.links = data.links;
                        dataToReturn.fileViews = data.file_views;
                        dataToReturn.public = data.public;
                        dataToReturn.root = data.root;
                        dataToReturn.lastActivity = data.last_activity;
                        dataToReturn.lastActivityDate = new Date(data.last_activity * 1000);
                        resolve(dataToReturn);
                    } else if (response.status === 400 || response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },

    /**
     * Check if a subdomain already exists.
     * @function checkSubdomain
     * @param {string} subdomain Name of the subdomain to check. Ex; 'sxcu.net'
     * @returns {Promise&lt;boolean>} Wether the subdomain exists or not.
     * @throws {ErrorResponse|any}
     * @memberof Subdomains
     * @instance
     */
    checkSubdomain: async function (subdomain) {
        return new Promise(function (resolve, reject) {
            fetch(`${baseUrl}/subdomains/check/${subdomain}`, {
                method: 'GET',
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'checkSubdomain');
                    if (response.status === 200) {
                        const data = await response.json();
                        resolve(data.exists);
                    } else if (response.status === 400 || response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },
};

/**
 * Methods that interact with the "Collections" endpoint.
 * @namespace Collections
 * @example
 * const { collections: sxcuCollections } = require("sxcu.api"); // sxcuCollections.&lt;method>
 * const { collections } = require("sxcu.api"); // collections.&lt;method>
 * const sxcu = require("sxcu.api"); // sxcu.collections.&lt;method>
 */
exports.collections = {
    /**
     * Represents a file object in a collection meta response.
     * @typedef {Object} CollectionMetaResponseFile
     * @property {Snowflake} id ID of the file.
     * @property {URL} url URL of the file.
     * @property {URL} thumbnail Thumbnail of the file.
     * @property {number} views The amount of views of the file.
     */

    /**
     * Represents the response returned by the 'getCollectionMeta' method.
     * @typedef {Object} CollectionMetaResponse
     * @property {Snowflake} id ID of the collection.
     * @property {URL} url URL of the collection.
     * @property {string} title Title of the collection.
     * @property {string} description Description of the collection.
     * @property {number} views The amount of views of the collection.
     * @property {number} creationTime Unix timestamp of when the collection was created.
     * @property {Date} creationTimeDate 'creationTime' converted to a Date object.
     * @property {boolean} public Whether the collection is public or not.
     * @property {boolean} unlisted Whether the collection is unlisted or not.
     * @property {number} fileViews Number of views all the files in this collection got combined.
     * @property {CollectionMetaResponseFile[]} files Files that belong to this collection.
     */

    /**
     * Get the meta information of a collection.
     * @function getCollectionMeta
     * @param {Snowflake} collectionId ID of the collection to get the meta info of.
     * @returns {Promise&lt;CollectionMetaResponse>} Collection meta response.
     * @throws {ErrorResponse|any}
     * @memberof Collections
     * @instance
     */
    getCollectionMeta: async function (collectionId) {
        return new Promise(function (resolve, reject) {
            fetch(`${baseUrl}/collections/${collectionId}`, {
                method: 'GET',
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'getCollectionMeta');
                    if (response.status === 200) {
                        const data = await response.json();
                        const returnedData = {};
                        returnedData.id = data.id;
                        returnedData.url = 'https://sxcu.net/c/' + data.id;
                        returnedData.title = data.title;
                        returnedData.description = data.desc;
                        returnedData.views = data.views;
                        returnedData.creationTime = data.creation_time;
                        returnedData.creationTimeDate = new Date(data.creation_time * 1000);
                        returnedData.public = data.public;
                        returnedData.unlisted = data.unlisted;
                        returnedData.fileViews = data.file_views;
                        returnedData.files = [];
                        for (const file of data.files) {
                            returnedData.files.push({
                                id: file.id,
                                url: file.url,
                                thumbnail: file.thumb,
                                views: file.views,
                            });
                        }
                        resolve(returnedData);
                    } else if (response.status === 400 || response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },

    /**
     * Response returned by the 'createCollection' method.
     * @typedef {Object} CreatedCollectionResponse
     * @property {Snowflake} collectionId ID of the collection.
     * @property {URL} url URL of the collection.
     * @property {string} title Title of the collection.
     * @property {string?} description Description of the collection.
     * @property {boolean} unlisted Whether this collection is unlisted or not.
     * @property {boolean} private Whether the collection is private or not.
     * @property {string?} collectionToken Upload token of the collection.
     */

    /**
     * Create a collection.
     * @function createCollection
     * @param {string} title Title of the collection.
     * @param {string} [description] Description of the collection.
     * @param {boolean} [isPrivate=false] If true, the collection will be private.
     * @param {boolean} [unlisted=false] If true, the collection will be unlisted.
     * @returns {Promise&lt;CreatedCollectionResponse>} Data about the newly created collection.
     * @throws {ErrorResponse|any}
     * @memberof Collections
     * @instance
     */
    createCollection: async function (title, description, isPrivate, unlisted) {
        // Note that isPrivate is not named 'private' due to jsdoc errors when generating.
        return new Promise(function (resolve, reject) {
            const params = new URLSearchParams();
            params.set('title', title);
            if (description) {
                params.set('desc', description);
            }
            if (isPrivate === true) {
                params.set('private', 'true');
            } else {
                params.set('private', 'false');
            }
            if (unlisted === true) {
                params.set('unlisted', 'true');
            }
            fetch(`${baseUrl}/collections/create`, {
                method: 'POST',
                body: params,
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'createCollection');
                    if (response.status === 200) {
                        const data = await response.json();
                        const returnedData = {};
                        returnedData.collectionId = data.collection_id;
                        returnedData.url = 'https://sxcu.net/c/' + data.collection_id;
                        returnedData.title = data.title;
                        returnedData.description = data.description ?? null;
                        returnedData.unlisted = data.unlisted;
                        returnedData.private = data.private;
                        returnedData.collectionToken = data.collection_token ?? null;
                        resolve(returnedData);
                    } else if (response.status === 400 || response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },
};

/**
 * Methods that interact with the "Links" endpoint.
 * @namespace Links
 * @example
 * const { links: sxcuLinks } = require("sxcu.api"); // sxcuLinks.&lt;method>
 * const { links } = require("sxcu.api"); // links.&lt;method>
 * const sxcu = require("sxcu.api"); // sxcu.links.&lt;method>
 */
exports.links = {
    /**
     * Represents the response returned by the 'createLink' method.
     * @typedef {Object} CreatedLinkResponse
     * @property {string} id ID of the new redirect link.
     * @property {URL} url URL of the new redirect link.
     * @property {URL} deletionUrl Deletion URL for the new redirect link.
     * @property {string} deletionToken Deletion token for the new redirect link.
     */

    /**
     * Create a link redirect.
     * @function createLink
     * @param {URL} link Link to redirect to.
     * @param {string} [subdomain] Subdomain to upload the link redirect to. Ex; 'shx.gg'
     * @returns {Promise&lt;CreatedLinkResponse>} Data about the newly created link redirect.
     * @throws {ErrorResponse|any}
     * @memberof Links
     * @instance
     */
    createLink: async function (link, subdomain) {
        return new Promise(function (resolve, reject) {
            const params = new URLSearchParams();
            params.set('link', link);
            let url = baseUrl;
            if (subdomain) {
                url = 'https://' + subdomain + '/api';
            }
            fetch(`${url}/links/create`, {
                method: 'POST',
                body: params,
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'createLink');
                    if (response.status === 200) {
                        const data = await response.json();
                        const returnedData = {};
                        returnedData.id = data.url.split('/').pop();
                        returnedData.url = data.url;
                        returnedData.deletionUrl = data.del_url;
                        returnedData.deletionToken = data.del_url.split('/').pop();
                        resolve(returnedData);
                    } else if (response.status === 400 || response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },

    /**
     * Delete a link redirect.
     * @function deleteLink
     * @param {string} linkId ID of the link redirect to delete.
     * @param {string} deletionToken Deletion token of the link redirect.
     * @returns {Promise&lt;string>} Message result.
     * @throws {ErrorResponse|any}
     * @memberof Links
     * @instance
     */
    deleteLink: async function (linkId, deletionToken) {
        return new Promise(function (resolve, reject) {
            fetch(`${baseUrl}/links/delete/${linkId}/${deletionToken}`, {
                method: 'GET',
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'deleteLink');
                    if (response.status === 200) {
                        const data = await response.json();
                        resolve(data.message);
                    } else if (response.status === 400 || response.status === 429) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },
};

/**
 * Methods that interact with the "Text" endpoint.
 * @namespace Text
 * @example
 * const { text: sxcuText } = require("sxcu.api"); // sxcuText.&lt;method>
 * const { text } = require("sxcu.api"); // text.&lt;method>
 * const sxcu = require("sxcu.api"); // sxcu.text.&lt;method>
 */
exports.text = {
    /**
     * Represents the response returned by the 'createPaste' method.
     * @typedef {Object} CreatedPasteResponse
     * @property {string} id ID of the new text paste.
     * @property {URL} url URL of the new text paste.
     * @property {URL} deletionUrl Deletion URL for the new text paste.
     * @property {string} deletionToken Deletion token for the new text paste.
     */

    /**
     * Create a text paste.
     * @function createPaste
     * @param {string} text Text that will be used in the text paste.
     * @returns {Promise&lt;CreatedPasteResponse>} Data about the newly created text paste.
     * @throws {ErrorResponse|any}
     * @memberof Text
     * @instance
     */
    createPaste: async function (text) {
        return new Promise(function (resolve, reject) {
            const params = new URLSearchParams();
            params.set('text', text);
            fetch(`${textBaseUrl}/upload`, {
                method: 'POST',
                body: params,
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'createPaste');
                    if (response.status === 200) {
                        const data = await response.json();
                        const returnedData = {};
                        returnedData.id = data.url.split('/').pop();
                        returnedData.url = data.url;
                        returnedData.deletionUrl = data.del_url;
                        returnedData.deletionToken = data.del_url.split('/').pop();
                        resolve(returnedData);
                    } else if (response.status === 400) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },

    /**
     * Delete a text paste.
     * @function deletePaste
     * @param {string} pasteId ID of the text paste to delete.
     * @param {string} deletionToken Deletion token of the text paste.
     * @returns {Promise&lt;string>} Message result.
     * @throws {ErrorResponse|any}
     * @memberof Text
     * @instance
     */
    deletePaste: async function (pasteId, deletionToken) {
        return new Promise(function (resolve, reject) {
            fetch(`${textBaseUrl}/d/${pasteId}/${deletionToken}`, {
                method: 'GET',
                headers: {
                    'User-Agent': userAgent,
                    Accept: 'application/json',
                },
            })
                .then(async function (response) {
                    saveRateLimitData(response.headers, 'deletePaste');
                    if (response.status === 200) {
                        const data = await response.json();
                        resolve(data.message);
                    } else if (response.status === 400) {
                        const data = await response.json();
                        reject({ error: data.error, code: data.code });
                    } else {
                        reject({
                            error: `Received status code ${response.status}.`,
                            code: 0,
                        });
                    }
                })
                .catch(function (error) {
                    reject({ error: `Request failed: ${error}`, code: -1 });
                });
        });
    },
};

/**
 * Methods that can provide some assistance when using other methods.
 * All methods defined as a utility method do not create API calls.
 * @namespace Utility
 * @example
 * const { utility: sxcuUtility } = require("sxcu.api"); // sxcuUtility.&lt;method>
 * const { utility } = require("sxcu.api"); // utility.&lt;method>
 * const sxcu = require("sxcu.api"); // sxcu.utility.&lt;method>
 */
exports.utility = {
    /**
     * Resolve an error, this can be used to guarantee the presence of a error and code value.
     * @function resolveError
     * @param {any} error Error to resolve.
     * @returns {ErrorResponse} Error response.
     * @memberof Utility
     * @instance
     */
    resolveError: function (error) {
        if (error) {
            if (typeof error === 'object' &amp;&amp; !Array.isArray(error)) {
                return { error: error.error ?? error.message ?? 'unknown', code: error.code ?? -1 };
            } else if (typeof error === 'string') {
                return { error: error, code: -1 };
            } else {
                return { error: toString(error).replace('[object Undefined]', 'unknown'), code: -1 };
            }
        } else {
            return { error: 'unknown', code: -1 };
        }
    },

    /**
     * Represents rate limit data.
     * @typedef {Object} RateLimitData
     * @property {number} limit Number of requests allowed.
     * @property {number} remaining Number of requests that can still be made.
     * @property {number} reset Epoch time of when the rate limit resets.
     * @property {number} resetAfter Total amount of time in seconds until the rate limit resets. Note that this value only updates when new rate limit data is processed.
     * @property {string} bucket A unique string that identifies the rate limit.
     * @property {Date} resetDate 'reset' converted to date object.
     */

    /**
     * Represents a rate limit.
     * @typedef {Object} RateLimit
     * @property {string[]} functions An array of function names that caused this rate limit. This array is always empty if 'global' is true.
     * @property {string} bucket A unique string that identifies the rate limit.
     * @property {RateLimitData} lastRateLimit Data of this rate limit.
     * @property {boolean} global Whether this rate limit is the global rate limit or not.
     */

    /**
     * Rate limit data object. This object contains all rate limit buckets, including global.
     * Key of each rate limit is the bucket, however global has the key 'global'.
     * WARNING: Modifying this object may cause issues.
     * @function getRateLimitData
     * @returns {Object.&lt;string, RateLimit>}
     * @memberof Utility
     * @instance
     */
    getRateLimitData: function () {
        return rateLimitData;
    },

    /**
     * Get the current rate limit that was provided by the specific method.
     * @function getRateLimitByMethod
     * @param {string} functionName Name of the method. Ex; 'uploadFile'
     * @returns {RateLimit|null}
     * @memberof Utility
     * @instance
     */
    getRateLimitByMethod: function (functionName) {
        const rateLimitData = this.getRateLimitData();
        let foundRateLimit = null;
        for (const entry of Object.entries(rateLimitData)) {
            const rateLimit = entry[1];
            if (rateLimit.functions.findIndex((name) => name === functionName) !== -1) {
                foundRateLimit = rateLimit;
            }
        }
        return foundRateLimit;
    },

    /**
     * Get the current global limit.
     * @function getGlobalRateLimit
     * @returns {RateLimit|null}
     * @memberof Utility
     * @instance
     */
    getGlobalRateLimit: function () {
        const rateLimitData = this.getRateLimitData();
        return rateLimitData['global'] ?? null;
    },

    /**
     * Get a promise that resolves when the rate limit(s) is no longer in effect.
     * This method will resolve instantly if the global rate limit and none of the provide function name's rate limits have been reached yet.
     * The global rate limit is always accounted for, even when providing a function name.
     * @function getRateLimitPromise
     * @param {string|string[]|'all'} [functionName] Name of the function or an array of function names that belong to the rate limit(s) that you need to get a promise for. Provide the string 'all' if you want all rate limits currently saved to be accounted for.
     * @returns {Promise&lt;void>}
     * @memberof Utility
     * @instance
     * @tutorial obeying-rate-limits
     */
    getRateLimitPromise: async function (functionName) {
        /**
         * Inner method for awaiting rate limits.
         * @function awaitRateLimit
         * @param {RateLimit} rateLimit
         * @returns {Promise&lt;void>}
         * @private
         */
        async function awaitRateLimit(rateLimit) {
            return new Promise(function (resolve) {
                const interval = setInterval(function () {
                    if (new Date() > rateLimit.lastRateLimit.resetDate) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 1000);
            });
        }
        const globalRateLimit = this.getGlobalRateLimit();
        if (globalRateLimit) {
            if (globalRateLimit.lastRateLimit.remaining === 0) {
                await awaitRateLimit(globalRateLimit);
            }
        }
        if (functionName) {
            if (Array.isArray(functionName)) {
                for (const method of functionName) {
                    const rateLimit = this.getRateLimitByMethod(method);
                    if (rateLimit) {
                        if (rateLimit.lastRateLimit.remaining === 0) {
                            await awaitRateLimit(rateLimit);
                        }
                    }
                }
            } else if (functionName === 'all') {
                const rateLimitData = this.getRateLimitData();
                for (const entry of Object.entries(rateLimitData)) {
                    const rateLimit = entry[1];
                    if (rateLimit.global === false) {
                        if (rateLimit.lastRateLimit.remaining === 0) {
                            await awaitRateLimit(rateLimit);
                        }
                    }
                }
            } else {
                const rateLimit = this.getRateLimitByMethod(functionName);
                if (rateLimit) {
                    if (rateLimit.lastRateLimit.remaining === 0) {
                        await awaitRateLimit(rateLimit);
                    }
                }
            }
        }
        return;
    },

    /**
     * Set the user agent.
     * Example: sxcuUploader/$versionNumber (+$url)
     * WARNING: Changing the user agent may cause API requests to be denied.
     * @function setUserAgent
     * @param {string} newUserAgent New User Agent to be used.
     * @returns {void}
     * @throws {ErrorResponse}
     * @memberof Utility
     * @instance
     */
    setUserAgent: function (newUserAgent) {
        if (typeof newUserAgent !== 'string') throw { error: 'User Agent must be a string.', code: -1 };
        userAgent = newUserAgent;
        return;
    },

    /**
     * Represents the response returned by "convertSxcuFile".
     * @typedef {Object} ConvertedSxcuFile
     * @property {string} domain Domain.
     * @property {UploadFileOptions} options File upload options.
     */

    /**
     * Convert a sxcu file to a UploadFileOptions object.
     * Note: Requires the file to have the correct options, it's preferred that the file is downloaded from sxcu.net.
     * You can use the "Custom Uploader Workshop" tool from https://sxcu.net/ to get the file needed for this method.
     * @function convertSxcuFile
     * @param {FilePath} file File which should be converted.
     * @returns {ConvertedSxcuFile}
     * @throws {ErrorResponse|any}
     * @memberof Utility
     * @instance
     */
    convertSxcuFile: function (file) {
        if (file.split('.').pop() !== 'sxcu') throw { error: 'File must be an sxcu file.', code: -1 };
        const fileString = fs.readFileSync(file).toString();
        const convertedJson = JSON.parse(fileString);
        if (!convertedJson) throw { error: 'Could not convert file content to JSON.', code: -1 };
        if (convertedJson.Version !== '13.6.1')
            console.warn(
                `Sxcu file version is not 13.6.1, current version is '${convertedJson.Version}'. Conversion may error or convert incorrectly. Please create an issue on github if the version you are using is greater. https://github.com/Lovely-Experiences/sxcu.api/issues`
            );
        const uploadFileOptions = {};
        const response = {};
        const data = convertedJson.Arguments;
        uploadFileOptions.token = data.token;
        uploadFileOptions.collection = data.collection;
        uploadFileOptions.collectionToken = data.collection_token;
        uploadFileOptions.noEmbed = data.noembed;
        uploadFileOptions.selfDestruct = data.self_destruct;
        if (data.og_properties !== undefined) {
            const convertedJson = JSON.parse(data.og_properties);
            const openGraphProperties = {};
            openGraphProperties.title = convertedJson.title;
            openGraphProperties.description = convertedJson.description;
            openGraphProperties.color = convertedJson.color;
            openGraphProperties.siteName = convertedJson.site_name;
            openGraphProperties.discordHideUrl = convertedJson.discord_hide_url;
            uploadFileOptions.openGraphProperties = openGraphProperties;
        }
        response.domain = convertedJson.RequestURL.split('/')[2];
        response.options = uploadFileOptions;
        return response;
    },

    /**
     * Create a sxcu queue.
     * This queue can be used to execute methods in a asynchronous manner.
     * @class
     * @memberof Utility
     * @instance
     * @example
     * const { utility } = require("sxcu.api");
     * const queue = new utility.queue();
     */
    queue: class queue {
        /**
         * Represents an object in the queue.
         * @typedef {Object} QueueObject
         * @property {function} function Method to be executed.
         * @property {function} finished Method to be executed once the function has been executed.
         * @property {string} [rateLimit] Rate limit that the method must obey.
         * @private
         */

        /**
         * Queue array.
         * @type {QueueObject[]}
         */
        #queueData = [];

        /**
         * Push a method/function to the queue.
         * @function push
         * @param {function} method Method that should be queued.
         * @param {string} [methodName] Name of the method. This is used to obey the rate limit for the method's specific endpoint. If nothing is provided, only the global rate limit will be obeyed.
         * @returns {Promise&lt;any>}
         * @memberof Utility#queue
         * @instance
         * @example
         * const { utility } = require('sxcu.api');
         * const queue = new utility.queue();
         * queue
         *  .push(() => {
         *      console.log('This function is being executed.');
         *  })
         *  .then(() => {
         *      console.log('The function in the queue has finished execution.');
         *      queue.stop();
         *  });
         */
        async push(method, methodName) {
            const self = this;
            return new Promise(function (resolve) {
                self.#queueData.push({
                    function: method,
                    finished: resolve,
                    rateLimit: methodName,
                });
            });
        }

        /**
         * Clear the queue.
         * @function clear
         * @returns {void}
         * @memberof Utility#queue
         * @instance
         */
        clear() {
            this.#queueData.length = 0;
            return;
        }

        /**
         * Queue interval result. (intervalID)
         * @type {number|null}
         */
        #intervalID = null;

        /**
         * Stop/pause the queue.
         * @function stop
         * @returns {void}
         * @memberof Utility#queue
         * @instance
         */
        stop() {
            return clearInterval(this.#intervalID);
        }

        /**
         * Start/unpause the queue.
         * @function start
         * @returns {void}
         * @memberof Utility#queue
         * @instance
         */
        start() {
            const self = this;
            let processing = false;
            this.#intervalID = setInterval(async function () {
                if (processing === true) return;
                processing = true;
                const queueObject = self.#queueData[0];
                if (queueObject) {
                    await exports.utility.getRateLimitPromise(queueObject.rateLimit);
                    try {
                        const result = await queueObject.function();
                        queueObject.finished(result);
                    } catch (error) {
                        queueObject.finished(exports.utility.resolveError(error));
                    }
                    self.#queueData[0] = undefined;
                    self.#queueData.forEach(function (value, index) {
                        if (index > 0) {
                            self.#queueData[index - 1] = value;
                            self.#queueData[index] = undefined;
                        }
                    });
                }
                processing = false;
            }, 1000);
        }

        /**
         * @param {boolean} [doNotStart] If true, the queue will not be executed until you call 'queue.start()'.
         * @constructs Utility#queue
         * @memberof Utility#queue
         * @instance
         */
        constructor(doNotStart) {
            if (doNotStart !== true) {
                this.start();
            }
        }
    },
};
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="CP0tdVsklKMPUSKxKLF_K"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Utility_queue.html">queue</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="ZU_t2b0sSlX75_L9zNS9U"><div>Namespaces</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Collections.html">Collections</a></div><div class="sidebar-section-children"><a href="Files.html">Files</a></div><div class="sidebar-section-children"><a href="Links.html">Links</a></div><div class="sidebar-section-children"><a href="Subdomains.html">Subdomains</a></div><div class="sidebar-section-children"><a href="Text.html">Text</a></div><div class="sidebar-section-children"><a href="Utility.html">Utility</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="AhGoesvHZVs2-NAnWF6WB"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-obeying-rate-limits.html">Obeying Rate Limits</a></div><div class="sidebar-section-children"><a href="tutorial-uploading-a-file.html">Uploading a File</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="xDMjSmo5Yc5y1efemKz9B"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#CollectionMetaResponse">CollectionMetaResponse</a></div><div class="sidebar-section-children"><a href="global.html#CollectionMetaResponseFile">CollectionMetaResponseFile</a></div><div class="sidebar-section-children"><a href="global.html#ConvertedSxcuFile">ConvertedSxcuFile</a></div><div class="sidebar-section-children"><a href="global.html#CreatedCollectionResponse">CreatedCollectionResponse</a></div><div class="sidebar-section-children"><a href="global.html#CreatedLinkResponse">CreatedLinkResponse</a></div><div class="sidebar-section-children"><a href="global.html#CreatedPasteResponse">CreatedPasteResponse</a></div><div class="sidebar-section-children"><a href="global.html#ErrorResponse">ErrorResponse</a></div><div class="sidebar-section-children"><a href="global.html#FileMetaResponse">FileMetaResponse</a></div><div class="sidebar-section-children"><a href="global.html#FileMetaResponseOpenGraphProperties">FileMetaResponseOpenGraphProperties</a></div><div class="sidebar-section-children"><a href="global.html#FilePath">FilePath</a></div><div class="sidebar-section-children"><a href="global.html#RateLimit">RateLimit</a></div><div class="sidebar-section-children"><a href="global.html#RateLimitData">RateLimitData</a></div><div class="sidebar-section-children"><a href="global.html#Snowflake">Snowflake</a></div><div class="sidebar-section-children"><a href="global.html#SubdomainListData">SubdomainListData</a></div><div class="sidebar-section-children"><a href="global.html#SubdomainMetaResponse">SubdomainMetaResponse</a></div><div class="sidebar-section-children"><a href="global.html#URL">URL</a></div><div class="sidebar-section-children"><a href="global.html#UploadFileOptions">UploadFileOptions</a></div><div class="sidebar-section-children"><a href="global.html#UploadFileOptionsOpenGraphProperties">UploadFileOptionsOpenGraphProperties</a></div><div class="sidebar-section-children"><a href="global.html#UploadedFileResponse">UploadedFileResponse</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>